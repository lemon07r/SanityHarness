package letter

import (
	"sync"
	"sync/atomic"
	"testing"
	"time"
)

func TestConcurrentFrequencyIsConcurrent(t *testing.T) {
	t.Cleanup(func() {
		frequencyStartHook = nil
	})

	var inFlight atomic.Int32
	started := make(chan struct{})
	release := make(chan struct{})

	frequencyStartHook = func() {
		if inFlight.Add(1) == 2 {
			close(started)
		}
		<-release
	}

	texts := []string{"aaaaaaaaaa", "bbbbbbbbbb", "cccccccccc", "dddddddddd"}

	done := make(chan struct{})
	go func() {
		_ = ConcurrentFrequency(texts)
		close(done)
	}()

	select {
	case <-started:
		// ok
	case <-time.After(500 * time.Millisecond):
		close(release)
		select {
		case <-done:
		case <-time.After(2 * time.Second):
		}
		t.Fatalf("ConcurrentFrequency did not process multiple texts concurrently")
	}

	close(release)

	select {
	case <-done:
	case <-time.After(2 * time.Second):
		t.Fatal("ConcurrentFrequency did not complete")
	}
}

// Verified strictly by `go test -race`. This test just creates contention.
func TestConcurrentFrequencyIsRaceFreeUnderConcurrency(t *testing.T) {
	texts := make([]string, 100)
	for i := range texts {
		texts[i] = "the quick brown fox jumps over the lazy dog"
	}

	var wg sync.WaitGroup
	for i := 0; i < 10; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			_ = ConcurrentFrequency(texts)
		}()
	}
	wg.Wait()
}
