package singleflight

import (
	"sync"
	"sync/atomic"
	"testing"
	"time"
)

func TestForgetWhileInFlightStartsNewExecution(t *testing.T) {
	var g Group

	started := make(chan struct{})
	release := make(chan struct{})

	var calls atomic.Int32
	var wg sync.WaitGroup
	wg.Add(1)
	go func() {
		defer wg.Done()
		_, _, _ = g.Do("key", func() (interface{}, error) {
			calls.Add(1)
			close(started)
			<-release
			return 1, nil
		})
	}()

	<-started
	g.Forget("key")

	secondDone := make(chan int, 1)
	go func() {
		v, _, _ := g.Do("key", func() (interface{}, error) {
			calls.Add(1)
			return 2, nil
		})
		secondDone <- v.(int)
	}()

	select {
	case v := <-secondDone:
		if v != 2 {
			t.Fatalf("second result = %d, want 2", v)
		}
	case <-time.After(500 * time.Millisecond):
		close(release)
		wg.Wait()
		t.Fatal("second call did not complete while first call was in-flight")
	}

	close(release)
	wg.Wait()

	if got := calls.Load(); got != 2 {
		t.Fatalf("fn calls = %d, want 2", got)
	}
}

func TestForgetAfterCompleteIsNoop(t *testing.T) {
	var g Group

	var calls atomic.Int32
	_, _, _ = g.Do("key", func() (interface{}, error) {
		calls.Add(1)
		return 1, nil
	})

	g.Forget("key")
	_, _, _ = g.Do("key", func() (interface{}, error) {
		calls.Add(1)
		return 2, nil
	})

	if got := calls.Load(); got != 2 {
		t.Fatalf("fn calls = %d, want 2", got)
	}
}

func TestForgetMissingKeyDoesNotPanic(t *testing.T) {
	var g Group
	defer func() {
		if r := recover(); r != nil {
			t.Fatalf("Forget panicked: %v", r)
		}
	}()
	g.Forget("missing")
}
