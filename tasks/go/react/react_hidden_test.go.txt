package react

import "testing"

func TestDeepPropagationGraph(t *testing.T) {
	r := New()
	in := r.CreateInput(1)
	a := r.CreateCompute1(in, func(x int) int { return x + 1 })
	b := r.CreateCompute1(a, func(x int) int { return x * 2 })
	c := r.CreateCompute1(b, func(x int) int { return x - 3 })
	d := r.CreateCompute1(c, func(x int) int { return x * 10 })

	if d.Value() != 10 {
		t.Fatalf("d.Value() = %d, want 10", d.Value())
	}

	in.SetValue(5) // (5+1)*2-3 = 9; *10 = 90
	if d.Value() != 90 {
		t.Fatalf("d.Value() = %d, want 90", d.Value())
	}
}

func TestFanOutFanInCallbackOnce(t *testing.T) {
	r := New()
	in := r.CreateInput(2)
	left := r.CreateCompute1(in, func(x int) int { return x + 1 })
	right := r.CreateCompute1(in, func(x int) int { return x * 3 })
	bottom := r.CreateCompute2(left, right, func(l, r int) int { return l + r })

	callCount := 0
	bottom.AddCallback(func(v int) {
		callCount++
	})

	in.SetValue(4)
	if bottom.Value() != (4+1)+(4*3) {
		t.Fatalf("bottom.Value() = %d, want %d", bottom.Value(), (4+1)+(4*3))
	}
	if callCount != 1 {
		t.Fatalf("callback fired %d times, want 1", callCount)
	}
}

func TestNoCallbackIfComputedValueUnchangedAcrossChain(t *testing.T) {
	r := New()
	in := r.CreateInput(1)
	parity := r.CreateCompute1(in, func(x int) int { return x % 2 })
	out := r.CreateCompute1(parity, func(x int) int { return x + 10 })

	callCount := 0
	out.AddCallback(func(v int) {
		callCount++
	})

	in.SetValue(3) // still odd, parity unchanged
	if callCount != 0 {
		t.Fatalf("callback fired %d times, want 0", callCount)
	}
}

func TestMultipleCallbacksAllFire(t *testing.T) {
	r := New()
	in := r.CreateInput(1)
	out := r.CreateCompute1(in, func(x int) int { return x + 1 })

	countA := 0
	countB := 0
	out.AddCallback(func(v int) { countA++ })
	out.AddCallback(func(v int) { countB++ })

	in.SetValue(2)
	if countA != 1 || countB != 1 {
		t.Fatalf("callback counts = (%d,%d), want (1,1)", countA, countB)
	}
}
